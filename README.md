# Отчет о лабораторной работе и модульном домашнем задании N2
## Введение
Целью работы была разработка скрипта на языке C++, преобразующего алгебраическое выражение, введенное пользователем в стандартной (инфиксной) форме в постфиксную запись согласно Обратной Польской Нотации и последующее определение значения результата выражения с учетом возможного появления переменной X.

## Часть 1. Структура
Проект представлен в 4 файлах:

**• main.cpp**

**• DZ.cpp**

**• lab.cpp**

**• lab_and_DZ.h**

Основной файл обрабатывает ввод, проверяет наличие переменной x и передает ввод в функции-обработчики, объявленные в заголовочном файле lab_and_DZ.h и реализованные в .cpp файлах lab.cpp и DZ.cpp.

## Часть 2. Реализация основного файла
В файле main.py код принимает ввод от пользователя и передает его в качестве параметра функции transform_to_postfix() и выводит результат:


```
std::string result = transform_to_postfix(input);
std::cout << "Postfix form: " << result << std::endl;
```
Далее программа проверяет наличие в результирующем выражении переменной X с использованием самописной вспомогательной функцией split():

```
for (size_t i = 0; i < splited.size(); ++i) {
if (splited[i] == "x") {
std::cout << "Enter x value: ";
...
```
Далее, имея выражение, перенаправляет его в функцию solve_from_postfix_form() и выводит результат на экран:

```
float res = solve_from_postfix_form(splited);
std::cout << "Problem result is: " << res << std::endl;
```
## Часть 3. Реализация LAB.cpp
В этом файле содержится одна функция:

```
std::string transform_to_postfix(const std::string& inp)
```
Она переводит данную в инфиксной форме строку inp в постфиксную форму согласно Обратной Польской Нотации. Функция проходит циклом по вводу, если встречает числа и переменные – просто дописывает их в результат.

На протяжении всего цикла поддерживается стек операторов, также глобально определены приоритеты операций (чем больше значение, тем больше приоритет), так, наивысший приоритет имеют унарные операторы, за ними возведение в степень, потом умножение/деление и сложение/вычитание. Если функция встречает оператор, она автоматически дозаписывает в результат все операции, лежащие на вершине стека по очереди, приоритет которых больше или равен текущей (именно так соблюдается приоритет), иначе просто пушит в стек текущую операцию.

```
while (!operations.empty() && priority[operations.top()] >= priority[operation] && operations.top() != "(") {
res += operations.top() + " ";
operations.pop();
}
operations.push(operation);
```
Если в выражении встречаются скобки, они обрабатываются отдельно, так как имеют высший приоритет, все выражение внутри скобок считается отдельным блоком и с закрытием скобки закрывается так, чтобы превратиться в один элемент после применения операций (логика аналогична стандартной, но добавляется ограничение в виде работы до закрывающей скобки):

```
else if (c == ')') {
while (!operations.empty() && operations.top() != "(") {
res += operations.top() + " ";
operations.pop();
}
}
```
## Часть 4. Реализация DZ.cpp
Этот файл выполняет основную роль – считает результат валидного арифметического выражения, переданного в постфиксной форме и содержит два основных элемента:

Словарь лямбда-функций для операций:

```
std::unordered_map<std::string, std::function<float(float, float)>> lambdas;
```
Саму функцию подсчета:

```
float solve_from_postfix_form(std::vector<std::string>& splited);
```
Функция проходится по выражению, встречая числовое значение добавляет его на стек. Если цикл встречает операцию, он, в зависимости от того, унарная она или бинарная применяет ее к одному или двум верхним элементам стека соответственно, потом заменяет их на результат применения, пример для унарной операции (с приоритетом 4):

```
if (priority[s] == 4) {
float temp = st.top();
st.pop();
st.push(lambdas[s](temp, 0));
}
```
Это гарантирует правильность порядка выполнения, а также то, что в конце получится стек с одним элементом (в случае непустого выражения). Этот элемент и будет результатом.

## Часть 5. Вывод
В данном домашнем задании мы создали алгоритм для определения результата выражения, переданного в инфиксной форме.

Эту задачу мы разбили на 2 шага:

**• Приведение выражения в постфиксный вид**

**• Решение выражения в постфиксном виде**

В ходе решения мы получили навыки работы со стеком и другими структурами данных.